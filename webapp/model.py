from hashlib import sha512
from operator import mul
from collections import defaultdict
from bigbrother.webapp.db import Stat, Whorl, Identity, WhorlToId
from google.appengine.ext import db

def build_raw_data(partial, environ, ip):

    rawdata = dict(partial)

    httpheaders = {}
    for key, value in environ.items():
        if key.startswith("HTTP_"):
            httpheaders[key] = value
    rawdata.update(httpheaders)
    rawdata["IP_ADDR"] = ip

    return rawdata


def get_whorls(rawdata):

    whorls = []
    keys = [db.Key.from_path("Whorl", hashed) for key, value, hashed in create_hashes(rawdata)]
    whorls = [w for w in db.get(keys) if w]

    #TODO: if the number of users grows large, we need to limit
    # the whorls we consider, because otherwise the set of users we need
    # to consider gets too large, and the memory and computing requirements
    # will grow too quickly. So we could do something like this:
    #
    #order_by(asc(Whorl.count)).\
    #limit(top)
    #
    # this only looks at rare whorls. This may not be the best solution. When the data
    # is sparse, if a player switches browsers there is very little or no overlap with
    # the whorls generated by the previous browser with this method.

    return whorls



def create_get_whorls(rawdata):
        
    whorls = []

    for name, value, hashed in create_hashes(rawdata):

        whorl = db.get(db.Key.from_path("Whorl", hashed))

        if not whorl:
            whorl = Whorl(key_name=hashed,
                          hashed=hashed,
                          name=name,
                          value=value)
            whorl.put()
            
        whorls.append(whorl)

    return whorls


def create_hashes(whorls, prefix=None):
    
    hashes = []

    for key, value in whorls.items():

        key = str(key) #these are always strings at the moment, but just in case.
        if prefix:
            key = prefix + ":" + key
            
        if type(value) == dict:
            hashes.extend(create_hashes(value, prefix=key))            
            
        elif type(value) == list:
            for item in value:
                hashes.extend(create_hashes(item, prefix=key))
                
        else:
            
            if type(value) != unicode:
                value = unicode(value)
                
            hashes.append((key,
                            value,
                            sha512((key + value).encode("utf-8")).hexdigest()))
            
    return hashes


def get_whorl_identities(whorls, identity):

    """
    Future me, enjoy debugging this one.
    """

    keys = [(identity,
              whorl,
              db.Key.from_path("Identity", str(identity.key()), "Whorl", whorl.key().name()))
              for whorl in whorls]
    
    wids = dict(zip(keys, db.get([key for id, whorl, key in keys])))

    for (id, whorl, key), wid in wids.items():
        if not wid:
            wid = Whorl(parent=id,
                        hashed = whorl.hashed,
                        name=whorl.name,
                        value=whorl.value)
            wids[(id, whorl, key)] = wid

    # create whorl -> ids
    idws = []
    for whorl in whorls:
        idw = db.get(db.Key.from_path("Whorl", whorl.key().name(), "WhorlToId", str(identity.key())))
        if not idw:
            idw = WhorlToId(parent=whorl,
                            idkey=str(identity.key()))
            idws.append(idw)

    db.put(idws)
    db.put(wids.values())

    return wids.values()


def learn(whorls, identity):
    
    """
    increment the count for whorlID probability, whorl, total_visits
    and identity.
    """

    identity.count = identity.count + 1
    total_visits = Stat.get(db.Key.from_path("Stat", "statsobj"))
    total_visits.value = total_visits.value + 1
    
    for whorl in whorls:
        whorl.count = whorl.count + 1

    wids = get_whorl_identities(whorls, identity)
    for wi in wids:
        wi.count = wi.count + 1

    db.put(wids + whorls)
    identity.put()
    total_visits.put()
        

def create_identity(name):
    identity = Identity(name=name)
    identity.put()
    return identity


def stats_obj():
    
    stat = db.get(db.Key.from_path("Stat", "statsobj"))
    if not stat:
        stat = Stat(key_name="statsobj", name="total_visits", value=1)
        stat.put()

    return dict([(stat.name, stat.value)])


                
def identify_from(whorls):

    stats = stats_obj()
    minprob = float(1) / stats["total_visits"]
    whorl_hashes = list(set([whorl.key().name() for whorl in whorls]))

    # 1. get the identities from the whorls
    # 2. get the probabilities of the whorls given the identity
    # 3. Use that to create a list of p(i)p(w | i)


    ids = db.get(list(set([wtid.idkey for wtid in WhorlToId.all().ancestor(whorl.key()).run()
                   for whorl in whorls])))
    
    whorls = []
    for identity in ids:
        for w in Whorl.all().ancestor(identity).run():
            if w.hashed in whorl_hashes:
                whorls.append(w)


    whorlprobs = defaultdict(lambda : defaultdict(lambda : minprob))
    for whorl in whorls:
        whorlprobs[whorl.parent()][whorl.key()] =\
            min(1, float(whorl.count) / whorl.parent().count)

    # this is a dictionary of dictionaries. The inner dictionaries
    # contain probabilities of the whorl given the user.
#    whorlids =defaultdict(lambda : defaultdict(lambda : minprob))
#    for wid in db.query(WhorlIdentity).\
#        filter(WhorlIdentity.whorl_hashed.in_(whorl_hashes)).\
#        all():

#        whorlids[wid.identity][wid.whorl_hashed] =\
#            min(1, float(wid.count) / wid.identity.count)

    # The probabilities above are then used to create a list
    # of probabilities per user for every whorl passed in.
    # The inner dictionary above defaults to a reasonable
    # minimum if we've never seen a whorl for a given user
    givenid = defaultdict(list)
    for identity, probs in whorlprobs.items():
        for whorl in whorls:
            givenid[identity].append(probs[whorl.key()])
            

    # These are all the probabilities put into a list of tuples so
    # it can be sorted by probability.
    probs = [(\
               # calculate the posterior probability p(whorl|identity)p(identity)
               reduce(mul, idprobs) * (float(identity.count) / stats["total_visits"]),\

               # identity id as a tie breaker in sorting. this is arbitrary. If there
               # is a tie, we just guess. could put a random number here I suppose.
               identity.key(),\

               # the identity tied to this probability.
               identity) \
               
               for identity, idprobs in givenid.items()]

    probs.sort()
    return probs[-1][2] # the most likely identity (third element is the identity)

